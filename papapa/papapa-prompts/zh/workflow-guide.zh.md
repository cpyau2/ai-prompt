# 如何使用5阶段开发工作流程

## 概述

此工作流程提供了使用LLM进行软件开发的结构化方法，跨越5个不同的阶段。每个阶段都有自己的重点提示，建立在之前的阶段之上。

## 工作流程结构

### 阶段1：需求收集

**包含：** `@base-prompt.md` + `@01-requirements-phase.md`

**目的：** 定义功能应该做什么

- LLM基于您的想法生成初始需求
- 与用户反馈迭代直到需求完整
- 创建 `specs/{feature_name}/01-requirements.md`

**示例：**

```
用户："我想构建一个将xlsx转换为JSON的Excel处理器"
→ LLM生成需求，迭代直到批准
```

### 阶段2：设计文档创建

**包含：** `@base-prompt.md` + `@02-design-phase.md`

**目的：** 设计功能将如何构建

- 基于批准的需求
- 进行研究并创建全面设计
- 创建 `specs/{feature_name}/02-design.md`
- 包括架构、组件、数据模型、测试策略
- 对于GUI功能：添加UI/UX设计、响应式设计、可访问性

**示例：**

```
用户："需求已批准，让我们设计它"
→ LLM创建设计文档，迭代直到批准
```

### 阶段3：实施计划创建

**包含：** `@base-prompt.md` + `@03-implementation-plan-phase.md`

**目的：** 将工作分解为可管理的编码任务

- 基于批准的设计
- 创建编号复选框列表的实施任务
- 仅专注于代码编写、修改和测试任务
- 创建 `specs/{feature_name}/03-implementation-plan.md`

**示例：**

```
用户："设计已批准，创建实施计划"
→ LLM创建任务列表，迭代直到批准
```

### 阶段4：实施计划执行

**包含：** `@base-prompt.md` + `@04-implementation-plan-execution.md`

**目的：** 执行计划的任务并生成代码

- 基于批准的实施计划
- 一次执行一个任务，用户审查
- 更新 `03-implementation-plan.md` 的进度
- 创建 `specs/{feature_name}/04-changes-log.md` 用于跟踪更改
- 区分信息请求和执行请求

**示例：**

```
用户："计划已批准，让我们开始实施"
→ LLM一个接一个地执行任务，更新进度
```

### 阶段5：文档更新

**包含：** `@base-prompt.md` + `@05-documentation-update.md`

**目的：** 更新所有文档以反映实际实施

- 审查阶段4期间所做的所有更改
- 将 `04-changes-log.md` 的更改合并回主文档
- 更新 `01-requirements.md`、`02-design.md`、`03-implementation-plan.md`
- 确保所有文档反映当前实施

**示例：**

```
用户："让我们用所有更改更新文档"
→ LLM更新所有文档以匹配实际实施
```

## 关键工作流程原则

### 1. 阶段进展

- 每个阶段都建立在之前的基础上
- 在进入下一阶段之前等待明确批准
- 如果需要重大更改，可以返回前一阶段

### 2. 迭代开发

- 为初始功能完成所有5个阶段
- 通过返回阶段1进行增强来开始新迭代
- 每次迭代都建立在之前工作的基础上

### 3. 变更管理

- 阶段4期间的快速修复：停留在阶段4
- 重大更改：返回适当的前一阶段
- 在阶段4期间在 `04-changes-log.md` 中记录所有更改
- 在阶段5中将更改合并回主文档

### 4. 用户控制

- LLM一次执行一个任务
- 每个任务后停止等待用户审查
- 区分信息请求和执行请求
- 在每个阶段等待明确批准

## 手动变更报告纪律

### 为什么报告手动变更

**对工作流程成功至关重要：** 您必须在阶段4期间向LLM报告所有手动代码更改。

### 报告什么

**代码更改：**

```
"我手动重构了用户认证逻辑"
"我为文件上传函数添加了错误处理"
"我优化了数据库查询以提高性能"
```

**架构更改：**

```
"我更改了文件夹结构以分离关注点"
"我将API端点移动到不同模块"
"我重新构建了组件层次结构"
```

**依赖/配置：**

```
"我添加了一个新的npm包用于日期格式化"
"我更新了数据库配置"
"我更改了构建过程"
```

### 如何报告

**每次您进行重大更改时：**

1. **告诉LLM** 您更改了什么
2. **解释为什么** 您进行了更改
3. **让LLM在** `04-changes-log.md` 中记录它

### 报告的好处

- **上下文保持：** LLM保持对实际代码的理解
- **文档准确性：** 阶段5可以正确更新文档
- **未来迭代：** 下次迭代有准确的上下文
- **完整审计跟踪：** 更改内容和原因的完整历史

## 真实世界示例

### Excel处理器示例

**阶段1：** xlsx → JSON转换的需求
**阶段2：** 带测试策略的设计（需要手动xlsx夹具）
**阶段3：** 实施计划，用户创建测试文件的具体任务
**阶段4：** 执行任务，暂停用户创建xlsx文件，继续
**阶段5：** 用实际实施细节更新文档

### 处理手动依赖

- 预先承认LLM限制（例如，无法生成xlsx文件）
- 在实施计划中为用户参与做计划
- 创建用户需要操作的清晰交接点
- 用户提供所需输入后恢复执行

### 错误修复和重构

- 立即在 `04-changes-log.md` 中记录更改
- 对更改进行分类：需求、设计、实施、见解
- 包含关于为什么进行更改的上下文
- 在阶段5中将所有更改合并回主文档

## 最佳实践

1. **从简单开始：** 从核心功能开始，迭代添加复杂性
2. **记录更改：** 跟踪开发过程中的所有修改
3. **用户审查：** 在继续之前始终等待批准
4. **清晰范围：** 每个阶段都有重点责任
5. **灵活转换：** 可以根据需要在阶段之间移动
6. **完整文档：** 保持所有文档当前和准确
7. **报告手动更改：** 始终告诉LLM您的代码修改

## 文件结构

```
specs/{feature_name}/
├── 01-requirements.md
├── 02-design.md
├── 03-implementation-plan.md
├── 04-changes-log.md (阶段4期间创建)
└── 05-documentation-update.md (阶段5输出)
```

此工作流程提供了一个结构化的、迭代的软件开发方法，在整个过程中保持质量、用户控制和全面文档。 